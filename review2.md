# Laravel Lesson レビュー②

## Todo編集機能

### @method('PUT')を記述した行に何が出力されているか
HTMLコードが出力されている。
HTMLのformタグではGETとPOST以外のメソッドを作れない仕様であるため<input type= (中略) method="put">を出力するディレクティブ「@method('PUT')」を使用している。

### findメソッドの引数に指定しているIDは何のIDか
編集ボタンや更新ボタンを押した際にリクエストとして送られてくる、操作対象のレコードのID(カラム名「id」)。

### findメソッドで実行しているSQLは何か
SELECT * FROM todos WHERE id = {$id};
※{$id}：操作対象のレコードのid。

### findメソッドで取得できる値は何か
引数に指定したidと一致するレコードの内容が格納されたTodoオブジェクト。

### saveメソッドは何を基準にINSERTとUPDATEを切り替えているのか
そのレコードがDBに存在するか否かを基準にして操作を切り替えています。
EXISTSを用いてレコードの存在チェックを行い、
存在する場合はUPDATE、存在しない場合はINSERTを行います。


## Todo論理削除

### traitとclassの違いとは
以降、traitをトレイト、classをクラスと記述します。
違いは2点あります。
1点目は利用できる数です。
どちらも外部の処理を利用することが出来ますが、トレイトは一つのクラスに複数追加して利用できるのに対し、クラスは親クラスからの継承でしか再利用できない上利用できる数はその親クラス1つのみです。
2点目はインスタンス化出来るか否かという点です。
クラスはインスタンス化が可能ですが、トレイトはインスタンス化出来ません。

### traitを使用するメリットとは
複数のクラス間でコードを共通化したり再利用することが出来ます。
これによりコードの可読性や作業の効率が上がります。


## その他

### TodoControllerクラスのコンストラクタはどのタイミングで実行されるか
Viewからリクエストが送信されweb.phpのルート定義にて処理が振り分けられるタイミングで実行されます。

### RequestクラスからFormRequestクラスに変更した理由
バリデーションを行うためです。
FormRequestクラスはRequestクラスを継承しつつバリデーションに特化したクラスなので、目的に沿う実装としてRequestクラスからFormRequestクラスに変更しました。

### $errorsのhasメソッドの引数・返り値は何か
引数：チェックしたい項目名
返り値：bool型で、エラーの有り/無しをtrue/falseで返します。

### $errorsのfirstメソッドの引数・返り値は何か
引数：チェックしたい項目名
返り値：チェックした結果出てきたエラーメッセージのうち最初のものを返します。エラーが無ければnullとなります。

### フレームワークとは何か
共通処理や構造を予めセットにしたもので、アプリケーション開発の枠組みとなるソフトウェアを指します。
アプリケーション開発において処理をゼロから書く必要が無く、工数削減に繋がる他、
開発者間で同じフレームワークを利用すれば同じ構造の処理を使うことになるので保守性も上がります。

### MVCはどういったアーキテクチャか
アプリケーションサーバ内の処理構造を、主な役割を持たせた3つの要素で構成する設計モデルを指します。
DBとのやり取りを担うModel、
実際にユーザが見る画面周りの処理を担うView、
ModelとViewの制御を担うControllerという役割を各プログラムに振り分け、
それらに応じた処理を実装していきます。この役割それぞれの頭文字を取って「MVC」と呼びます。
このような構造にすることでコードが役割毎に独立するため、
コードの管理がしやすくなる上、バグが発生しても原因調査が容易になります。

### ORMとは何か、またLaravelが使用しているORMは何か
クラスとDBにあるテーブルを関連付け、そのクラスのメソッドを用いるだけで関連付けられたDBとのやり取りを行えるプログラム技術です。
正式には「Object-Relational Mapping」と呼び、"関連付け"をマッピングと言います。
Laravelが使用しているORMはEloquentです。

### composer.json, composer.lockとは何か
PHPのパッケージやライブラリを管理するツールをcomposerと言いますが、
そのcomposerを初めてインストールする際に参照されるのがcomposer.jsonです。

composerのインストールが始まると、composer.jsonに書かれた内容を基にパッケージ等がvendorディレクトリに保存されます。
この時composer.lockも同時に生成され、インストールされたパッケージやそのバージョン情報が書き込まれます。

そして、もしcomposerを再度インストールする時はcomposer.lockが参照されます。最初にインストールしたものと同じバージョンのものを参照するため環境を整えやすい仕組みと言えます。

### composerでインストールしたパッケージ（ライブラリ）はどのディレクトリに格納されるのか
vendorディレクトリです。